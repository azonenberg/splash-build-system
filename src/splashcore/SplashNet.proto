syntax = "proto3";

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Individual message packet types

//Identify the server to clients
message ServerHello
{
	uint32	magic		= 1;	//magic number, always "BILD"
	uint32	version		= 2;	//protocol version supported by server (always 1 for now)
};

//Identify the client to the server
message ClientHello
{
	uint32	magic		= 1;	//magic number, always ("BILD")
	uint32	version		= 2;	//protocol version supported by server (always 1 for now)

	enum ClientType
	{
		CLIENT_DEVELOPER = 0;	//splashdev
		CLIENT_BUILD = 1;		//splashbuild
		CLIENT_UI = 2;			//splash
	};
	uint32	type		= 3;	//type of client

	string	hostname	= 4;	//hostname for debug messages

	string	uuid		= 5;	//UUID of the client.
								//The UUID for a build server doesn't matter for now as long as it's unique.
								//UUIDs are used to link splashdev and splash instances together so
								//they must be the same for any given client.
};

//Report basic information about a developer client
message DevInfo
{
	string	arch 		= 1;	//client architecture triplet
};

//Report that a file changed clientside
message FileChanged
{
	string	fname		= 1;	//path of changed file
	string	hash		= 2;	//ASCII hex SHA-256 sum of the changed file
	bool	body		= 3;	//set to true if the file is a build script and we should load the body
	bool	config		= 4;	//set to true if the file is a build script and we should load the config
};

//Report that a file was deleted clientside
message FileRemoved
{
	string	fname		= 1;	//path of changed file
};

//Tell a client whether a given file is in the cache or not
message FileAck
{
	bool	fileCached	= 1;	//true if in cache, false if we have to send content
};

//Send contents of a file to the server
message FileData
{
	bytes	fileData	= 1;	//the contents of the file
};

//Report basic info about a build server, so we can schedule jobs more effectively
message BuildInfo
{
	uint32	cpuCount	= 1;	//Number of logical CPU cores on the system
	uint32	cpuSpeed	= 2;	//Processor speed according to some arbitrary benchmark.
								//Used to prioritize jobs so faster servers get work first
								//when the cluster is lightly loaded.
								//For now just use bogomips, TODO something more accurate
	uint32	ramSize		= 3;	//RAM capacity, in MB
	//code 4 reserved for RAM speed if we want to add that

	uint32	numchains	= 5;	//Number of toolchains on the node
};

//Report compilers installed on the build server
message AddCompiler
{
				uint32	compilerType= 1;	//Type of compiler (Toolchain::CompilerType)
				uint32	versionNum	= 2;	//Machine-readable version number of compiler, left justified hex.
											//Two octets for major version.
											//4.9.2 is encoded as 0x0400090200
				string	hash		= 3;	//ID hash of the compiler
				string	versionStr	= 4;	//Human-readable version string
	repeated	uint32	lang		= 5;	//Array of languages
	repeated	string	triplet		= 6;	//Array of architecture triplets

	//The following flags are only meaningful / present for toolchains that produce native executables.
	//Must be set to the empty string (not null) for other cases.
				string	exeSuffix	= 7;	//Executable file suffix, including the dot if required (.exe, empty string, etc)
				string	shlibSuffix	= 8;	//Shared library suffix, including the dot if required (.dll, .so, etc)
				string	stlibSuffix = 9;	//Static library suffix, including the dot if required (.lib, .a, etc)
				string	objSuffix	= 10;	//Object file suffix, including the dot if requied (.obj, .o, etc)
};

//Request that a build server perform a dependency scan on a specific source file
message DependencyScan
{
				string	toolchain	= 1;	//Hash of the toolchain being requested
				string	fname		= 2;	//Name of the file being scanned
				string	hash		= 3;	//Hash of the file being scanned
	repeated	string	flags		= 4;	//Array of compiler flags which may be important for dependency resolution
											//(include directories, #define's, etc)
};

//Request content of multiple source files by hash
message ContentRequestByHash
{
	repeated	string	hash		= 1;	//list of hashes being requested
};

//Content of a single file
message FileContent
{
				bytes	data		= 1;	//Content of the file (if status = true)
				bool	status		= 2;	//true if OK, false if file could not be retrieved
};

//Content of the requested files
message ContentResponse
{
	repeated	FileContent	data	= 1;	//Array of files being requested
};

//A single dependency
message Dependency
{
				string	hash		= 1;	//Hash of the file.
											//This is important for system headers, etc not in the actual working copy
				string	fname		= 2;	//Relative path of the file
};

//The result of a dependencyScan job
message DependencyResults
{
	repeated	Dependency	deps	= 1;	//list of results
				bool		result	= 2;	//true if successful, false if syntax error etc
};

//Client request for various kinds of data
message InfoRequest
{
	enum RequestType
	{
		TARGET_LIST		= 0;	//Get list of all targets (not split by arch/config)
		CONFIG_LIST		= 1;	//Get list of all configurations we have at least one target for
		ARCH_LIST		= 2;	//Get list of all architectures we have at least one target for
		TARGET_ARCHES	= 3;	//Get list of architectures for a given target
		TARGET_CONFIGS	= 4;	//Get list of configurations for a given target
		CLIENT_LIST		= 5;	//Get list of all connected clients
		TOOLCHAIN_LIST	= 6;	//Get list of all toolchains (and the resolved settings for them)
		NODE_DEPS		= 7;	//Get the dependency list for a specific graph node (by relative path)

		//TODO: stdout etc for a target's build
	};

				uint32		type	= 1;	//Type of query

				uint32		query	= 2;	//The name of the object being queried, if applicable
};

//Info about a single target
message TargetInfo
{
				string		name		= 1;	//name of the target
				string		script		= 2;	//name of the script we were declared in
				string		toolchain	= 3;	//name of the toolchain we use
};

//Info about many targets
message TargetList
{
	repeated	TargetInfo	info	= 1;	//list of target structs
};

//A list of configurations (response to CONFIG_LIST or TARGET_CONFIGS)
message ConfigList
{
	repeated	string		configs	= 1;	//List of config names
};

//A list of architectures (response to ARCH_LIST or TARGET_ARCHES)
message ArchList
{
	repeated	string		arches	= 1;	//List of architectures
};

//Info about a single client
message ClientInfo
{
	ClientHello.ClientType	type		= 1;	//Type of the client
				string		hostname	= 2;	//Hostname of the client
				string		uuid		= 3;	//UUID of the client
};

//A list of connected clients
message ClientList
{
	repeated	ClientInfo	infos		= 1;	//List of clients we know about
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Top-level message type

message SplashMsg
{
	oneof Payload
	{
		ServerHello 			serverHello	 			= 1;
		ClientHello 			clientHello				= 2;
		DevInfo					devInfo					= 3;
		FileChanged 			fileChanged				= 4;
		FileRemoved 			fileRemoved				= 5;
		FileAck					fileAck					= 6;
		FileData				fileData				= 7;
		BuildInfo				buildInfo				= 8;
		AddCompiler				addCompiler 			= 9;
		DependencyScan			dependencyScan			= 10;
		ContentRequestByHash	contentRequestByHash	= 11;
		ContentResponse			contentResponse			= 12;
		DependencyResults		dependencyResults		= 13;
		InfoRequest				infoRequest				= 14;
		TargetList				targetList				= 15;
		ConfigList				configList				= 16;
		ArchList				archList				= 17;
		ClientList				clientList				= 18;
	}
};
